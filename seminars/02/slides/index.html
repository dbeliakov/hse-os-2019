<!DOCTYPE html><html lang="en"><head><title>Архитектура компьютера и операционные системы</title><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../../common/shower/themes/ribbon/styles/screen-16x10.css"><style type="text/css">.caption {
    color: #FFF;
}</style></head><body class="shower list"><header class="caption"><h1>Архитектура компьютера и операционные системы</h1><p>Семинар 2. Стандартный ввод-вывод</p></header><section id="cover" class="slide"><h2>Семинар 2. Стандартный ввод-вывод</h2><p>Архитектура компьютера и операционные системы @ ВШЭ, 2019-2020</p><img src="../../../common/cover.jpg" alt="" class="cover"><style type="text/css">#cover h2 {
    margin: 30px 0 0;
    color: #FFF;
    text-align: center;
    font-size: 70px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p {
    margin: 10px 0 0;
    text-align: center;
    color: #FFF;
    font-style: italic;
    font-size: 20px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p a {
    color: #FFF;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}</style></section><section class="slide"><h2>Стандартная библиотека C</h2><ul><li>Функции стандартной библиотеки Си легко вызвать из других языков (в нашем случае, из программы на ассемблере)</li><li>Стандартная библиотека Си по умолчанию thread-safe (это нам потребуется в дальнейшем)</li><li>Стандартная библиотека Си (иногда существенно) быстрее</li><li>Форматный ввод-вывод Си, несмотря на особенности, может оказаться удобнее в использовании</li></ul></section><section class="slide"><h2>Стандартные потоки ввода-вывода</h2><ul><li>Стандартный поток ввода - программа считывает входные данные (условно) с клавиатуры</li><li>Стандартный поток вывода - программа выводит резуальтаты (условно) на экран</li><li>Условно - потому что вместо экрана и клавиатуры могут быть разные сущности, и программа об это не узнает</li></ul></section><section class="slide"><h2>Стандартные потоки ввода-вывода</h2><p><b>Текстовый поток</b> — это последовательность символов, разбитая на строки, каждая из которых содержит нуль
или более символов и завершается символом новой строки</p><p>Обязанность следить за тем, чтобы любой поток ввода-вывода отвечал этой модели, возложена на библиотеку:
программист, пользуясь библиотекой, не должен заботиться о том, в каком виде строки представляются вне программы</p></section><section class="slide"><h2>Посимвольные чтение и запись</h2><ul><li><code>getchar</code> - возвращает следующий считанный символ</li><li><code>putchar</code> - печатает символ на стандартный поток вывода</li></ul></section><section class="slide"><h2>Посимвольное чтение и запись</h2><pre><code style="font-size: 15pt;">#include &lt;stdio.h&gt;

int	getchar(void);		// equivalent to getc(stdin)
int	getc(FILE *);		// possibly MACRO, equivalent to fgetc()
int	fgetc(FILE *);

int putchar(int);		// equivalent to putc(c,stdout)
int putc(int, FILE *);	// possibly MACRO, equivalent to fputc()
int fputc(int, FILE *);</code></pre></section><section class="slide"><h2>Посимвольное чтение и запись</h2><ul><li>Как отличить конец файла от прочих символов? Использовать значение, которое не может быть кодом символа</li><li><code>EOF</code> - целая константа, определенная в &lt;stdio.h&gt; и имеющая тип int (в большинстве реализаций
стандартной библиотеки эта константа равна <code>-1</code>, но для переносимости кода следует использовать именно имя <code>EOF</code>)</li><li>Нужно помнить, что знаковость типа <code>char</code> не определена по стандарту</li></ul></section><section class="slide"><h2>Посимвольное чтение и запись</h2><ul><li><code>char c = getchar();</code>  - <b>неправильно</b>, патаемся записать 257 значений в тип, максимальная вместимость которого 256</li><li><code>int c = getchar();</code>  - <b>правильно</b></li><li>Функции вывода интерпретируют полученный символ (типа <code>int</code>) как <code>unsigned char</code></li></ul></section><section class="slide"><h2>Специальные символы</h2><ul><li><code>'\n'</code> - символ перевода новой строки,</li><li><code>'\r'</code> - символ возврата каретки,</li><li><code>'\t'</code> - символ табуляции,</li><li><code>'\b'</code> - символ забоя (backspace),</li><li><code>'\\'</code> - собственно, символ обратной косой черты,</li><li><code>'\''</code> - одинарная кавычка (апостроф),</li><li><code>'\"'</code> - двойная кавычка.</li></ul></section><section class="slide"><h2>Построчный ввод</h2><ul><li><code>fgets</code> - позволяют вводить последовательность символов из входного потока до достижения символа конца строки \n или до конца файла (что наступит раньше)</li><li>Функция заполняет буфер фиксированного размера, параметры которого передаются этой функции</li><li>Более подробное рассмотрение отложим до рассмотрения темы строк</li></ul></section><section class="slide"><h2>Форматированный ввод-вывод</h2><ul><li>Позволяют преобразовывать значения между внутренним представлением и текстовыми последовательностями, которые могут быть прочитаны и записаны</li><li>Функции печати, объявленные в заголовочном файле <code>&lt;stdio.h&gt;</code>, преобразуют внутреннее представление в последовательности типа char ипозволяют комбинировать последовательности для вывода. К этой группе относятся, например, функции <code>fprintf</code>, <code>printf</code>, <code>sprintf</code>, <code>snprintf</code></li></ul></section><section class="slide"><h2>Форматированный ввод-вывод</h2><ul><li>Функции сканирования, объявленные в <code>&lt;stdio.h&gt;</code>, преобразуют последовательности типа char и позволяют сканировать считываемые последовательности.К этой группе относятся функции <code>fscanf</code>, <code>scanf</code>, <code>sscanf</code></li></ul></section><section class="slide"><h2>Форматированный ввод-вывод</h2><ul><li>Один из недостатков - <b>типонебезопасность</b>, т.е. можно передать аргументы для ввода-вывода, не соотвествующие по количеству или по типам переданной форматной строке</li><li><code>-Wformat</code> - включает проверку формата и аргументов, включается также <code>-Wall</code> (чтобы было ошибкой, надо использовать <code>-Werror</code>)</li></ul></section><section class="slide"><h2>Задание форматирования</h2><ul><li>Для задания форматирования используют символ процента и следующий за ним спецификатор</li><li><a href="https://ejudge.ru/study/3sem/formatio.pdf">Полное описание правил форматирования</a></li></ul></section><section class="slide"><h2>Форматированный вывод</h2><pre><code style="font-size: 16pt;">#include &lt;stdio.h&gt;

int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);</code></pre></section><section class="slide"><h2>Форматированный ввод</h2><pre><code style="font-size: 16pt;">#include &lt;stdio.h&gt;

int scanf(const char *format, ... );
int fscanf(FILE *stream, const char *format, ... );	
int sscanf(const char *s, const char *format, ... );</code></pre></section><section class="slide"><h2>Форматированный ввод</h2><p>Функция форматирования завершает работу при следующих условиях</p><ul><li>Она достигает конца форматиной строки</li><li>Она не может получить очередной символ входного текста</li><li>Перобразование заканчивается неудачей (ошибка сопоставления)</li></ul><p>В случае успеха возвращается число обработанных аргументов, или ноль, если был неуспешным разбор самого первого аргумента</p></section><section class="slide"><h2>Файловый ввод-вывод</h2><pre><code style="font-size: 16pt;">#include &lt;stdio.h&gt;

FILE *fopen(const char *filename, const char *mode);
int fclose(FILE *stream);</code></pre></section><section class="slide"><h2>Файловый ввод-вывод</h2><ul><li>r - открытие файла на чтение</li><li>w - открытие файла на запись, при этом если файл существовал, то содержимое его удаляется (т.е. обнуляется длина файла), если же файл не существовал, то он создается</li><li>a - открытие файла на запись в конец; если файл не существовал, он создается</li><li>r+ - открытие на чтение и запись</li></ul></section><section class="slide"><h2>Файловый ввод-вывод</h2><ul><li>w+ - открытие на чтение и запись с обнулением длины существующего файла или созданием нового файла</li><li>a+ - открытие на чтение и запись в конец файла, если файл не существовал, он создается</li></ul><p>Дополнительно может задаваться символ b в строке mode (открывается бинарный файл, не играет роли в *nix-системах, но имеет значение при работе в Windows-системах)</p></section><section class="slide"><h2>Буферизация вывода</h2><p>Все выводимые символы предварительно сохраняются в буфере вывода, и выводятся на терминал в одном из случаев (построчная буферизация):</p><ul><li>Буфер переполнен (как правило, его размер не менее 4 килобайт)</li><li>Работа программы завершилась</li><li>Вывод в поток содержит символ перевода строки '\n'</li><li>Вызвана функция чтения с терминала, например, <code>scanf</code></li><li>Буфер принудительно сброшен с помощью функции <code>fflush</code></li></ul></section><section class="slide"><h2>Буферизация вывода</h2><p>Если стандартный поток вывода перенаправлен в файл или в канал, или данные выводятся в файл (полная буферизация):</p><ul><li>Буфер переполнен (как правило, его размер не менее 4 килобайт)</li><li>Работа программы завершилась</li><li>Буфер принудительно сброшен с помощью функции <code>fflush</code></li></ul><p>Принципиальное отличие стандартного потока stderr от stdout заключается в отсутствии буферизации</p></section><section class="slide"><h2>Буферизация ввода</h2><ul><li>Например, функция <code>getchar</code> пытается считать со стандартного потока ввода сразу блок данных размером буфера ввода</li><li>Функция fflush применима к некоторым входным потокам. Она пытается вернуть пока непрочитанную часть входного буфера обратно в файл. Ни к терминалам, ни к каналам эта функция неприменима (в будущем будем считать это ошибкой)</li></ul></section><section class="slide"><h2>Управление буферизацией</h2><p>Можно настраивать буферизацию файловых потоков с помощью <code>setbuf</code>, <code>setbuffer</code>, <code>setlinebuf</code>, <code>setvbuf</code></p></section><section class="slide"><h2>Потокобезопасность</h2><ul><li>Потокобезопасность имеет свою цену, но в однопоточных программах она не нужна</li><li><code>*_unlocked</code> - скорость таких функций превосходит не-unlocked аналоги</li><li>Не стандартная библиотека C (но по стандарту POSIX)</li></ul></section><div class="progress"></div><script src="../../../common/shower/shower.min.js"></script></body></html>