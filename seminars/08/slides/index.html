<!DOCTYPE html><html lang="en"><head><title>Архитектура компьютера и операционные системы</title><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../../common/shower/themes/ribbon/styles/screen-16x10.css"><style type="text/css">.caption {
    color: #FFF;
}</style></head><body class="shower list"><header class="caption"><h1>Архитектура компьютера и операционные системы</h1><p>Семинар 8. Введение в ассемблер</p></header><section id="cover" class="slide"><h2>Семинар 8. Введение в ассемблер</h2><p>Архитектура компьютера и операционные системы @ ВШЭ, 2019-2020</p><img src="../../../common/cover.jpg" alt="" class="cover"><style type="text/css">#cover h2 {
    margin: 30px 0 0;
    color: #FFF;
    text-align: center;
    font-size: 70px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p {
    margin: 10px 0 0;
    text-align: center;
    color: #FFF;
    font-style: italic;
    font-size: 20px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p a {
    color: #FFF;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}</style></section><section class="slide"><h2>Введение в ассемблер</h2><ul><li>Мы будем использовать AT&T синтаксис для записи инструкций ассемблера x86</li><li>Для компиляции используем gcc - <code>gcc -m32 source.S</code></li><li>Расширение для файлов исходного кода - <code>.S</code></li><li>64-битная версия системы может не поддерживать 32-битную архитектуру, лечение - <code>sudo apt-get install gcc-multilib</code></li><li>Первое время разрешено использовать мини-библиотеку <code>simpleio_x86.S</code></li></ul></section><section class="slide"><h2>Регистры процессора</h2><ul><li>Сверхбыстрая память внутри процессора, предназначенная прежде всего для хранения промежуточных результатов вычисления или содержащая данные, необходимые для работы процессора</li><li>Для большинства операций значение должно быть загружено в один из регистров</li><li>Регистры общего назначения, сегментные регистры, регистр флагов, указатель команды </li></ul></section><section class="slide"><h2>Регистры общего назначения</h2><ul><li><code>%eax</code>: Accumulator register — аккумулятор, применяется для хранения результатов промежуточных вычислений</li><li><code>%ebx</code>: Base register — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти</li><li><code>%ecx</code>: Counter register — счетчик, его неявно используют некоторые команды для организации циклов</li><li><code>%edx</code>: Data register — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода</li></ul></section><section class="slide"><h2>Регистры общего назначения</h2><ul><li><code>%esp</code>: Stack pointer register — указатель стека. Содержит адрес вершины стека</li><li><code>%ebp</code>: Base pointer register — указатель базы кадра стека (англ. stack frame). Предназначен для организации произвольного доступа к данным внутри стека</li><li><code>%esi</code>: Source index register — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник</li><li><code>%edi</code>: Destination index register — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник</li></ul></section><section class="slide"><h2>Регистры общего назначения</h2><img src="./img/reg.png" style="height: 30%;"><p>Большая их часть может использоваться для хранения совершенно произвольных данных. Единственный случай, когда нужно учитывать, в какой регистр помещать данные — использование неявно обращающихся к регистрам команд. Такое поведение всегда чётко документировано</p></section><section class="slide"><h2>Регистр флагов</h2><ul><li>Нужно рассматривать как массив битов, за каждым из которых закреплено определённое значение</li><li>Неявно передаётся дополнительная информация, которая не записывается непосредственно в результат вычислений</li><li><code>cf</code>: carry flag, флаг переноса (1 - был перенос из старшего бита результата, беззнаковое переполнение)</li><li><code>zf</code>: zero flag, флаг нуля (1 - результат операции нулевой)</li><li><code>of</code>: overflow flag, флаг переполнения (1 - было знаковое переполнение)</li></ul></section><section class="slide"><h2>Указатель команды</h2><ul><li><code>eip</code>: instruction pointer, указатель команды, регистр напрямую недоступен, изменяется неявно командами условных и безусловных переходов, вызова и возврата из подпрограмм</li></ul></section><section class="slide"><h2>Стек вызовов</h2><ul><li>Стек является неотъемлемой частью архитектуры процессора и поддерживается на аппаратном уровне: в процессоре есть специальные регистры и команды для работы со стеком</li><li>Обычно стек используется для сохранения адресов возврата и передачи аргументов при вызове процедур, также в нём выделяется память для локальных переменных</li><li>Стек располагается в оперативной памяти</li><li>Стек растёт в сторону младших адресов</li></ul></section><section class="slide"><h2>Стек вызовов</h2><img src="./img/stack.png"></section><section class="slide"><h2>Работа со стеком</h2><ul><li>При операции <code>push АРГУМЕНТ</code> значение <code>%esp</code> уменьшается на размер элемента в байтах, новый элемент записывается по адресу, на который указывает <code>%esp</code></li><li>При операции <code>pop АРГУМЕНТ</code> содержимое памяти по адресу, который записан в <code>%esp</code>, записывается в регистр, а значение адреса в <code>%esp</code> увеличивается на размер элемента в байтах</li></ul></section><section class="slide"><h2>Сегменты памяти</h2><img src="./img/segments.png" style="height: 80%;"></section><section class="slide"><h2>Секции кода в ассемблере</h2><ul><li>Данные помещаются в секцию данных - директива <code>.data</code></li><li>Команды (и, возможно, константные данные) помещаются в секцию кода - директива <code>.text</code></li><li>Неинициализированные данные (зарезервированные) определяются специальной секции - директива <code>.bss</code></li><li>Константные данные можно поместить в отдельную секцию (часть секции кода) - директива <code>.section .rodata</code></li></ul></section><section class="slide"><h2>Команды</h2><ul><li>Состоят из обозначения инструкции процессора и операндов</li><li>Операндов может не быть, или быть несколько (до 3х)</li><li>Конкретное значение, известное на этапе компиляции (непосредственные) - через <code>$</code></li><li>Регистр - название регистра с префиксом <code>%</code></li><li>Указатель на ячейку памяти - об этом в следующий раз</li><li>Неявные операнд - подразумевается инструкцией</li></ul></section><section class="slide"><h2>Команды</h2><ul><li>Суффикс обозначения команды говорит о том, к какому количеству байт применяется операция</li><li><code>b</code> (от англ. byte) — 1 байт</li><li><code>w</code> (от англ. word) — 2 байта</li><li><code>l</code> (от англ. long) — 4 байта</li><li><code>q</code> (от англ. quad) — 8 байт</li></ul></section><section class="slide"><h2>Команды</h2><ul><li>Важной особенностью всех команд является то, что они не могут работать с двумя операндами, находящимися в памяти. Хотя бы один из них следует сначала загрузить в регистр, а затем выполнять необходимую операцию</li></ul></section><section class="slide"><h2>Данные</h2><ul><li><code>.byte</code> — размещает каждое выражение как 1 байт</li><li><code>.short</code> — 2 байта</li><li><code>.int</code> — 4 байта</li><li><code>.quad</code> — 8 байт</li><li>Аргументы этих директив — список выражений, разделенных запятыми</li></ul></section><section class="slide"><h2>Данные</h2><ul><li><code>.ascii "STR"</code> размещает строку STR. Нулевых байтов не добавляет</li><li><code>.string "STR"</code> размещает строку STR, после которой следует нулевой байт (как в языке C)</li><li>У директивы <code>.string</code> есть синоним <code>.asciz</code> (z от англ. zero — ноль, указывает на добавление нулевого байта)</li><li>Строка-аргумент этих директив может содержать стандартные escape-последовательности</li></ul></section><section class="slide"><h2>Неинициализированные данные</h2><ul><li>В скомпилированной программе секция <code>.bss</code> не занимает места</li><li><code>.space  количество_байт</code></li></ul></section><section class="slide"><h2>Выравнивание</h2><ul><li>Выравнивание - забота программиста на ассемблере</li><li><code>.p2align степень_двойки, заполнитель, максимум</code> - смещает адрес до необходимого выравнивания, заполняя указанными данными</li><li>Если нужно добавить больше, чем максимум байт, то выравнивание не выполняется</li></ul></section><section class="slide"><h2>Метки и символы</h2><ul><li>Метка — это просто константа, значение которой — адрес</li><li><code>hello_str: .string "Hello"</code></li><li>Псевдометка <code>. </code> - текущий адрес</li><li>Значение метки - всегда адрес. Символ - некоторая константа (в т.ч. метка - символ)</li><li><code>.set    символ, выражение</code> - определить символ</li></ul></section><section class="slide"><h2>Метки и символы</h2><ul><li>Программа <code>nm</code> позволяет посмотреть символы скомпилированного файла</li><li>Символ можно сделать глобальным (экспортируемым) с помощью директивы <code>.global</code></li></ul></section><section class="slide"><h2>Некоторые команды</h2><ul><li>Суффиксы - <code>b</code> - 1 байт, <code>w</code> - 2 байта, <code>l</code> - 4 байта, <code>q</code> - 8 байт</li><li><code>mov ИСТОЧНИК, НАЗНАЧЕНИЕ</code></li><li>Хотя бы один из аргументов - регистр</li></ul></section><section class="slide"><h2>Некоторые команды</h2><ul><li>Операции со стеком - <code>push ЗНАЧЕНИЕ</code>, <code>pop КУДА</code></li><li>Стек считается выровненным по 4 байтам, хотя и можно положить 2 байта (но не 1)</li><li><code>pushl %esp</code> положит на стек значение до изменения значения регистра</li></ul></section><section class="slide"><h2>Некоторые команды</h2><ul><li><code>inc ОПЕРАНД</code></li><li><code>dec ОПЕРАНД</code></li><li><code>add ИСТОЧНИК, ПРИЕМНИК</code></li><li><code>sub ИСТОЧНИК, ПРИЕМНИК</code></li><li><code>mul МНОЖИТЕЛЬ1</code> - второй множитель находится в <code>%eax</code>, результат - в <code>%eax</code> и <code>%edx</code></li></ul></section><section class="slide"><h2>Некоторые команды</h2><ul><li><code>loop МЕТКА</code> - уменьшить <code>%ecx</code> на 1, если получился 0 - идти дальше, нет - перейти на метку</li><li><code>cmp ОПЕРАНД1, ОПЕРАНД2</code> - вычислить <code>ОПЕРАНД1 - ОПЕРАНД2</code> и установить флаги. Результат не сохраняется</li><li><code>jz</code>, <code>jnz</code>, <code>jc</code>, <code>jnc</code>, <code>jo</code>, <code>jno</code>, <code>jg</code>, <code>jge</code>, <code>jl</code>, <code>jle</code>, <code>ja</code>, <code>jae</code>, <code>jb</code>, <code>jbe</code> - условные переходы на основании значений флагов, аргумент - адрес (метка)</li><li><code>jmp АДРЕС</code> - безусловный переход</li></ul></section><section class="slide"><h2>Некоторые команды</h2><ul><li><code>and</code>, <code>or</code>, <code>xor</code>, <code>not</code> - логические операции, значение записывается в приемник (последний аргумент)</li><li><code>test</code> - как команда <and></and>, но не сохраняет результат, а только устанавливает флаги</li><li>Рекомендуется использовать <code>test</code> вместо <code>cmp</code> для сравнения с нулем</li><li><code>xor</code> часто применяют для обнуления регистров</li></ul></section><section class="slide"><h2>Некоторые команды</h2><ul><li><code> sal/shl КОЛИЧЕСТВО_СДВИГОВ, НАЗНАЧЕНИЕ</code> - Shift Arithmetic Left / SHift logical Left </li><li><code>sar/shr</code> - аналогично для правого сдвига</li><li>Каждый «выдвигаемый» бит попадает в флаг cf (сохраняется последний)</li><li><code>ror</code>, <code>rol</code> - циклический сдвиг вправо/влево, в cf сохраняется последний выдвинутый бит</li><li><code>rcr</code>, <code>rcl</code> - циклический сдвиг с cf как дополнительный бит</li></ul></section><section class="slide"><h2>Подпрограммы</h2><ul><li><code>call МЕТКА</code> - вызов подпрограммы</li><li><code>ret</code>, <code>ret ЧИСЛО</code> - возврат из подпрограммы</li><li>Подпрограмма может изменить значения регистров, но обязана сохранить <code>%ebp</code>, <code>%ebx</code> <code>%esi</code> <code>%edi</code>, <code>%esp</code>. Сохранение остальных регистров - задача программиста</li><li>Возвращаемое значение - через регистр <code>%eax</code></li><li>Подробности работы и передача параметров - в следующий раз</li></ul></section><div class="progress"></div><script src="../../../common/shower/shower.min.js"></script></body></html>