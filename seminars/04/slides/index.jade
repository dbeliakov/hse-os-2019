doctype html
html(lang="en")
    head
        title Архитектура компьютера и операционные системы
        meta(charset="utf-8")
        meta(http-equiv="x-ua-compatible", content="ie=edge")
        meta(name="viewport", content="width=device-width, initial-scale=1")
        link(rel="stylesheet", href="../../../common/shower/themes/ribbon/styles/screen-16x10.css")
        style(type="text/css").
            .caption {
                color: #FFF;
            }
    body.shower.list
        header.caption
            h1 Архитектура компьютера и операционные системы
            p Семинар 4. Вещественные типы данных
        section.slide#cover
            h2 Семинар 4. Вещественные типы данных
            p Архитектура компьютера и операционные системы @ ВШЭ, 2019-2020
            img.cover(src="../../../common/cover.jpg", alt="")
            style(type="text/css").
                #cover h2 {
                    margin: 30px 0 0;
                    color: #FFF;
                    text-align: center;
                    font-size: 70px;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
                #cover p {
                    margin: 10px 0 0;
                    text-align: center;
                    color: #FFF;
                    font-style: italic;
                    font-size: 20px;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
                #cover p a {
                    color: #FFF;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
        section.slide
            h2 Фиксированная точка
            img(src="img/fixed.gif")
            ul
                li Фиксированное количество бит на целую и дробную части
                li Пример: #[code 2.5 = 0010.1000]
                li Содержит ошибки в силу конечного числа бит. Ошибка не превышает половины веса младшего разряда (напр., 0.03125 для 8 бит)
        section.slide
            h2 Фиксированная точка
            ul
                li Сложение и вычитание - как целые числа
                li Умножение: 16-битный результат округляем до 8 бит
                li Деление: дополняем нулями до 16 бит и делим как целые, округляем
                li Округление по умолчанию - к ближайшему четному, четное - младший значащий бит = 0
        secton.slide
            h2 Плавающая точка
            ul
                li Стандарт IEEE 754, поддерживается во всех основных архитектурах (если нет - программаная реализация)
                li Появление обусловлено требованиями числовых расчетов
                li Компромисс между точностью и диапазоном принимаемых значений
                li Аналог экспоненциальной записи чисел, но только в памяти компьютера
        section.slide
            h2 Плавающая точка
            img(src="img/float.png" style="width: 80%")
            ul
                li (−1)^S×M×B^E, где S — знак, B — основание (2), E — порядок (экспонента, показатель степени), а M — мантисса
        section.slide
            h2 Плавающая точка
            ul
                li Половинная точность - занимает в памяти половину машинного слова
                li Одинарная точность - занимает в памяти машинное слово
                li Двойная точность - занимает в памяти два машинных слова
        section.slide
            h2 Плавающая точка
            ul
                li Порядок записывается как целое число в коде со сдвигом (сдвиг 2^b - 1, где b - число бит порядка)
                li Мантисса кодируется со "скрытой" единицей
        section.slide
            h2 Нормализованная форма
            ul
                li Мантисса принимает значения от 1.xxxxxxx (аналог 1.xxx-9.xxx для десятичных)
                li Любое число (кроме 0) записывается единственным образом
                li Ноль представить в таком виде невозможно
                li Старший бит не записывается (но всегда учитывается)
        section.slide
            h2 Денормализованная форма
            ul
                li Порядок записывается как целое число в коде со сдвигом
                li Каждое значение денормализованного числа меньше самого маленького нормализованного значения
                li Порядок - все биты равны нулю
                li Мантисса - ненулевая
                li Тогда считается, что порядок - на единицу больше, а старший бит мантиссы - 0
        section.slide
            h2 Денормализованная (субнормальная) форма
            ul
                li Ввиду сложности денормализованные числа крайне редко реализуют на аппаратном уровне - вместо этого используются программные реализации, работающие значительно медленнее
                li Т.к. денормализованные числа получаются действительно очень маленькими и практически никак не влияют на результат некоторых вычислений, часто они игнорируются
                li Flush-to-zero (FTZ) и Denormals-are-zero (DAZ)
        section.slide
            h2 Специальные значения
            ul
                li Число считается нулём, если все его биты, кроме знакового, равны нулю
                li NaN представлен как число, в котором все двоичные разряды порядка — единицы, а мантисса не нулевая
                li Число с плавающей запятой считается равным бесконечности, если все двоичные разряды его порядка — единицы, а мантисса равна нулю. Знак бесконечности определяется знаковым битом числа
        section.slide
            h2 Умножение и деление
            ul
                li Умножение в нормализованной форме - перемножить мантиссы, сложить порядки, округлить и нормализовать полученное число
                li Деление в нормализованной форме - разделить мантиссу делимого на мантиссу делителя и вычесть из порядка делимого порядок делителя, округлить и нормализовать
        section.slide
            h2 Сложение и вычитание
            ul
                li Идея - приведение чисел к одному порядку
                li Сначала выбирается оптимальный порядок, затем мантиссы обоих чисел представляются в соответствии с новым порядком, затем над ними производится сложение/вычитание, мантисса результата округляется и, если нужно, результат приводится к нормализированной форме
        section.slide
            h2 Свойства операций
            ul
                li Сложение не ассоциативно: #[code (a + b) + c != a + (b + c)]
                li Умножение не ассоциативно: #[code (a * b) * c != a * (b * c)]
                li Умножение не дистрибутивно: #[code a * (b + c) != a * b + a * c]
        section.slide
            h2 Unit in the last place
            ul
                li a, b - ближайшие друг к другу представимые числа, a &lt; b, ULP = b - a
                li Если a = 1, то ULP - машинный эпсилон
                li Во #[code float.h] - #[code FLT_EPSILON], #[code DBL_EPSILON], #[code LDBL_EPSILON]
                li Сравнение на равенство чисел с плавающей запятой - только через неравенство
        section.slide
            h2 Получение представления вещественного числа
            ul
                li Перевести модуль данного числа в двоичную систему счисления
                li Нормализовать двоичное число
                li Прибавить к порядку смещение и перевести смещенный порядок в двоичную систему счисления
                li Учитывая знак заданного числа, выписать его представление в памяти
    
        div(class="progress")
        script(src="../../../common/shower/shower.min.js")