doctype html
html(lang="en")
    head
        title Архитектура компьютера и операционные системы
        meta(charset="utf-8")
        meta(http-equiv="x-ua-compatible", content="ie=edge")
        meta(name="viewport", content="width=device-width, initial-scale=1")
        link(rel="stylesheet", href="../../../common/shower/themes/ribbon/styles/screen-16x10.css")
        style(type="text/css").
            .caption {
                color: #FFF;
            }
    body.shower.list
        header.caption
            h1 Архитектура компьютера и операционные системы
            p Семинар 11. Введение в ассемблер. Часть 4
        section.slide#cover
            h2 Семинар 11. Введение в ассемблер. Часть 4
            p Архитектура компьютера и операционные системы @ ВШЭ, 2018-2019
            img.cover(src="../../../common/cover.jpg", alt="")
            style(type="text/css").
                #cover h2 {
                    margin: 30px 0 0;
                    color: #FFF;
                    text-align: center;
                    font-size: 70px;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
                #cover p {
                    margin: 10px 0 0;
                    text-align: center;
                    color: #FFF;
                    font-style: italic;
                    font-size: 20px;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
                #cover p a {
                    color: #FFF;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }

        section.slide
            h2 Системные вызовы
            ul
                li Взаимодействие с железом (вывести на экран, прочитать с диска, сетевое взаимодействие и т.д.) может проводить только ядро ОС
                li Пользовательские программы выполняются в пространстве памяти пользователя, к пространству памяти ядра пользователю запрещен доступ
                li Системный вызов — способ обращения программы пользовательского пространства к пространству ядра

        section.slide
            h2 Системные вызовы
            ul
                li В архитектуре x86 во время системного вызова как минимум происходит увеличение уровня привилегий, замена пользовательских сегментов на сегменты ядра и установка регистра IP на обработчик системного вызова
                li Системные вызовы для высокоуровневых языков обычно обернуты в функции, однако механизм самих системных вызовов отличается
                li Теоретически, реализовать syscall можно при помощи любого исключения (деление на 0 и т.д.). Главное — передача управления ядру

        section.slide
            h2 Реализация системных вызовов
            ul
                li Включается защита от чтения/записи/исполнения кода пользовательского пространства
                li Заменяется пользовательский стек на стек ядра, сохраняются callee-saved регистры
                li Выполняется обработка системного вызова
                li Восстановление стека, регистров
                li Отключение защиты
                li Выход из системного вызова

        section.slide
            h2 Системный вызов в linux
            ul
                li Изначально, в архитектуре x86, Linux использовал программное прерывание 128 для совершения системного вызова
                li Для указания номера системного вызова, пользователь задаёт в eax номер системного вызова
                li Параметры располагает по порядку в регистрах ebx, ecx, edx, esi, edi, ebp
                li Вызывается инструкция int 80h
                li #[a(href="https://habr.com/ru/post/347596/") Эволюция системных вызовов]

        section.slide
            h2 Некоторые системные вызовы
            ul
                li #[code void exit(int code);] (#[code __NR_exit = 1])
                li #[code ssize_t read(int fd, void *ptr, size_t size);] (#[code __NR_read = 3])
                li #[code ssize_t write(int fd, const void *ptr, size_t size);] (#[code __NR_write = 4])

        section.slide
            h2 Компиляция без стандартной библиотеки
            ul
                li Флаг #[code -nostdlib] говорит, что программу не надо линковать со стандартной библиотекой C
                li Частью стандартной библиотеки является код инициализации, который выполняет необходимую инициализацию стандартной библиотеки, и затем вызывает #[code main]
                li При компиляции без стандартной библиотеки точка фхода в программу - метка #[code _start]

        section.slide
            h2 Компиляция без стандартной библиотеки
            ul
                li Ядро передает управление на точку #[code _start] не как вызов подпрограммы, то есть для завершения программы нельзя использовать инструкцию #[code ret]. Для завершения программы нужно использовать системный вызов #[code exit]
                li Аргументы (argc, argv и env) передаются #[a(href="http://asm.sourceforge.net/articles/startup.html#st") через стек]
                li В C можно писать функцию #[code void _start()], однако она будет следовать соглашениям о вызовах
        
        section.slide
            h2 Ассемблерные вставки
            ul
                li Позволяют писать код на ассемблере внутри кода на C
                li Инструкция: #[code asm] (расширение GNU) или #[code __asm___] (рекомендуемо)
                li Базовая форма - код на ассемблере вставляется как есть (может быть вне функции, компилятор предполагает, что не меняются ни регистры, ни память)
                li Расширенная форма - используются макроподстановки (фактически, можем легко взаимодействовать с внешним кодом)

        section.slide
            h2 Ассемблерные вставки
            ul
                li При использовании расширенной формы можно указывать, где ожидается аргумент (определенный регистр, регистр общего назначения, память и т.п.)
                li #[a(href="https://gamedev.ru/code/articles/gcc_inline_asm") Подробно все расписано тут]
                li Неправильно описанная вставка может работать при #[code -O0] и #[code -O1], но не работать при #[code -O2]


        div(class="progress")
        script(src="../../../common/shower/shower.min.js")