<!DOCTYPE html><html lang="en"><head><title>Архитектура компьютера и операционные системы</title><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../../common/shower/themes/ribbon/styles/screen-16x10.css"><style type="text/css">.caption {
    color: #FFF;
}</style></head><body class="shower list"><header class="caption"><h1>Архитектура компьютера и операционные системы</h1><p>Семинар 5. Массивы, указатели и строки</p></header><section id="cover" class="slide"><h2>Семинар 5. Массивы, указатели и строки</h2><p>Архитектура компьютера и операционные системы @ ВШЭ, 2019-2020</p><img src="../../../common/cover.jpg" alt="" class="cover"><style type="text/css">#cover h2 {
    margin: 30px 0 0;
    color: #FFF;
    text-align: center;
    font-size: 70px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p {
    margin: 10px 0 0;
    text-align: center;
    color: #FFF;
    font-style: italic;
    font-size: 20px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p a {
    color: #FFF;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}</style></section><section class="slide"><h2>Массивы</h2><ul><li>Массив - это непрерывная область памяти, в которой подряд хранятся элементы одного типа</li><li>Размер массива равен произведению размера одного элемента на количество элементов</li><li>Количество элементов в определении массива можно не указывать, если его можно определить из инициализатора массива</li><li>Массив не может содержать отрицательное число элементов, но массивы с нулем элементов допустимы. Их размер равен 0</li></ul></section><section class="slide"><h2>Массивы</h2><ul><li>Массив нельзя возвращать из функции</li><li>Массив в качетве аргумента - фактически, указатель на первый элемент массива</li><li>В контекстах, где компилятору не нужно знать размер массива, самый левый размер может опускаться</li><li>При модификациях массива в функции он модифицируется и во вне</li><li>Максив индексируется с 0, обращение за пределы массива - UB</li></ul></section><section class="slide"><h2>Указатели</h2><ul><li>Указатель содержит адрес области памяти, получение адреса - <code>&</code>, разыменование - <code>*</code></li><li>Специальное значение <code>NULL</code>. <code>0</code> сравнивается и приводится к <code>NULL</code>, однако в памяти <code>NULL</code> может быть <a href="https://stackoverflow.com/questions/9894013/is-null-always-zero-in-c">представлен не всеми нулями</a></li><li><code>NULL</code> в <code>if</code> сичтается ложным значением, другое - истинным</li><li>Обращение по указателю <code>NULL</code> - UB, и компилятор <a href="https://godbolt.org/z/eMhlBj">может делать оптимизационные предположения</a></li></ul></section><section class="slide"><h2>Операции над указателями</h2><ul><li>Арифметические операции над указателями определены в терминах операций над индексами массива</li><li>При приведении типа указателя к указателю на тип другого размера, поведение указателя меняется</li><li>Для указателя определены сложение и вычитание с целыми числами</li><li>Два указателя можно вычесть друг из друга. Если первый указатель меньше второго, или указатели от разных массивов - UB</li></ul></section><section class="slide"><h2>Операции над указателями</h2><ul><li>Указатель на обрасть памяти, следующую за последним элеменом массива - частая практика, однако разыменовывать его нельзя</li><li>Операция обращения по индексу так же применима к указателям. При этом допустимы отрицательные индексы в случае, когда не происходит выхода за пределы массива</li></ul></section><section class="slide"><h2>Указатели и <code>const</code></h2><ul><li><code>const</code> до символа <code>*</code> - нельзя изменять данные, на которые ссылается указатель</li><li><code>const</code> после символа <code>*</code> - нельзя менять сам указатель</li><li>Т.о. в типе может использоваться два раза ключевое слово <code>const</code>: <code>const char* const s = ...</code></li></ul></section><section class="slide"><h2>Представление строки</h2><ul><li>Фактически, строка - это массив символов <code>char</code>, где последний символ равен <code>'\0'</code></li><li>Все функции для работы над строками считают нулевой байт концом строки. При применении таких функций к бинарным данным результат может быть рекорректным</li><li>Все функции ожидают указатель на первый символ строки, и получают следующие символы инкрементом. Если строка не заканчивается нулевым байтом, будет выход за пределы массива</li></ul></section><section class="slide"><h2>Представление строки</h2><ul><li>Размер массива для хранения строки всегда минимум на единицу больше самой строки</li><li><code>const</code> при объявлении строки может влиять на размещение в памяти: <code>const char[] str = "Hello";</code> может быть размещена в области памяти, доступной только для чтения. Язык <code>C</code> позполяет снять константность, но в этом случае может быть segmentation fault</li></ul></section><section class="slide"><h2>Функции для обработки строк</h2><ul><li>Функция может обработать строку "на месте" - результат будет записан в том же буффере. Применимо в случае, когда размер результирующей строки не больше исходной</li><li>Функция может вернуть строку в новом динамически выделенном буфере (с помощью <code>malloc</code> и <code>realloc</code>) - в этом случае необходимо освобождать память (<code>free</code>)</li><li>Функция может принимать буфер для результата (и его размер)</li></ul></section><section class="slide"><h2>Функции для обработки строк</h2><pre><code style="font-size: 14pt;">char *concatenate(const char *str1, const char *str2)
{
    size_t len1 = strlen(str1);
    size_t len2 = strlen(str2);
    char *ret = malloc(len1 + len2 + 1); // не забываем \0-байт
    if (ret) {
        memcpy(ret, str1, len1);
        memcpy(ret + len1, str2, len2 + 1);
    }
    return ret;
}</code></pre></section><section class="slide"><h2>Функции для обработки строк</h2><p>Если функция принимает только один параметр для записи строки-результата - адрес буфера,
при этом невозможно контролировать длину строки, которая будет записана в этот буфер, такую
функцию использовать крайне опасно (по меньшей мере). Например, функция <code>gets</code>, которая
считывает одну строку из стандартного потока ввода и сохраняет ее по указанному адресу,
безусловно запрещена к использованию</p></section><section class="slide"><h2>Чтение строки</h2><ul><li><code>char *fgets(char *buf, size_t size, FILE *fin);</code></li><li>Возвращает NULL при ошибке чтения или достижении конца файла. В противном случае функция возвращает указатель <code>buf</code></li><li>Строка текста заканчивается либо символом '\n', либо концом файла, либо исчерпанием места в буфере <code>buf</code></li><li>Если символ <code>'\n'</code> считан, он помещается в буфер</li><li>Функцию допустимо использовать, когда есть ограничение на максимальную длину строки текста во входном файле</li></ul></section><section class="slide"><h2>Чтение строки</h2><ul><li>У функций семейства scanf есть форматное преобразование %s. Оно требует указатель на буфер строки</li><li>Предварительно пропускаются все пробельные символы, чтение в строку ведется либо до конца файла, либо до первого пробельного символа</li><li>Необходимо указать максимальное число считываемых символов следующим образом (просто <code>%s</code> недопустим)</li></ul></section><section class="slide"><h2>Вывод строки</h2><ul><li><code>printf("%s", buf);</code></li><li><code>fputs(buf, stdout);</code></li><li><code>printf(buf);</code> - <b>запрещено</b>! <a href="https://www.youtube.com/watch?v=0WvrSfcdq1I">Пример эксплоита</a></li></ul></section><section class="slide"><h2>Форматное чтение и запись</h2><ul><li><code>int snprintf(char *buf, size_t size, const char *format, ...);</code></li><li><code>int sscanf(char *str, const char *format, ...);</code></li><li>В случае чтения из строки удобно использовать форматное преобразование <code>%n</code></li></ul></section><section class="slide"><h2>Контролируемое преобразование из строки в число</h2><ul><li>Требуется, чтобы при чтении числа не возникало переполнение, в хвосте числа не находится "мусор"</li><li>Допустимо - "12", " -12" (пробелы перед числом допускаются)</li><li><code>strtol</code>, <code>strtoll</code>, <code>strtoul</code>, <code>strtoull</code>, <code>strtod</code></li></ul></section><section class="slide"><h2>Контролируемое преобразование из строки в число</h2><ul><li>Если возникло переполнение, в переменную <code>errno</code> записывается код ошибки <code>ERANGE</code></li><li>В переменную, адрес которой передан вторым параметром, записывается указатель на первый символ, который не является частю считанного числа</li></ul></section><section class="slide"><h2>Контролируемое преобразование из строки в число</h2><p>Проверка корректности чтения с помощью strtol заключается в следующем:</p><ul><li>проверить, что строка не пуста</li><li>проверить, что переменная errno не установлена</li><li>проверить, что eptr указывает на нулевой байт</li></ul></section><section class="slide"><h2>Инициализация выделенной памяти</h2><ul><li><code>void *memset(void *s, int c, size_t n);</code> - заполняет массив из <code>n</code> байт, который находится по адресу <code>s</code> однобайтными значениями <code>c</code></li><li>Эту функцию можно (и нужно) вызывать после выделения памяти для массива или буфера, иначе с большой вероятностью, выделенная память будет содержать какие-то случайные значения</li></ul></section><section class="slide"><h2>Динамическое выделение памяти</h2><ul><li><code>void* malloc(size_t n_bytes);</code></li><li><code>void free(void *pointer);</code></li><li><code>void *realloc(void *oldptr, size_t newsize);</code></li></ul></section><div class="progress"></div><script src="../../../common/shower/shower.min.js"></script></body></html>