doctype html
html(lang="en")
    head
        title Архитектура компьютера и операционные системы
        meta(charset="utf-8")
        meta(http-equiv="x-ua-compatible", content="ie=edge")
        meta(name="viewport", content="width=device-width, initial-scale=1")
        link(rel="stylesheet", href="../../../common/shower/themes/ribbon/styles/screen-16x10.css")
        style(type="text/css").
            .caption {
                color: #FFF;
            }
    body.shower.list
        header.caption
            h1 Архитектура компьютера и операционные системы
            p Семинар 5. Массивы, указатели и строки
        section.slide#cover
            h2 Семинар 5. Массивы, указатели и строки
            p Архитектура компьютера и операционные системы @ ВШЭ, 2019-2020
            img.cover(src="../../../common/cover.jpg", alt="")
            style(type="text/css").
                #cover h2 {
                    margin: 30px 0 0;
                    color: #FFF;
                    text-align: center;
                    font-size: 70px;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
                #cover p {
                    margin: 10px 0 0;
                    text-align: center;
                    color: #FFF;
                    font-style: italic;
                    font-size: 20px;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
                #cover p a {
                    color: #FFF;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
        section.slide
            h2 Массивы
            ul
                li Массив - это непрерывная область памяти, в которой подряд хранятся элементы одного типа
                li Размер массива равен произведению размера одного элемента на количество элементов
                li Количество элементов в определении массива можно не указывать, если его можно определить из инициализатора массива
                li Массив не может содержать отрицательное число элементов, но массивы с нулем элементов допустимы. Их размер равен 0
        section.slide
            h2 Массивы
            ul
                li Массив нельзя возвращать из функции
                li Массив в качетве аргумента - фактически, указатель на первый элемент массива
                li В контекстах, где компилятору не нужно знать размер массива, самый левый размер может опускаться
                li При модификациях массива в функции он модифицируется и во вне
                li Максив индексируется с 0, обращение за пределы массива - UB
        section.slide
            h2 Указатели
            ul
                li Указатель содержит адрес области памяти, получение адреса - #[code &], разыменование - #[code *]
                li Специальное значение #[code NULL]. #[code 0] сравнивается и приводится к #[code NULL], однако в памяти #[code NULL] может быть #[a(href="https://stackoverflow.com/questions/9894013/is-null-always-zero-in-c") представлен не всеми нулями]
                li #[code NULL] в #[code if] сичтается ложным значением, другое - истинным
                li Обращение по указателю #[code NULL] - UB, и компилятор #[a(href="https://godbolt.org/z/eMhlBj") может делать оптимизационные предположения]
        section.slide
            h2 Операции над указателями
            ul
                li Арифметические операции над указателями определены в терминах операций над индексами массива
                li При приведении типа указателя к указателю на тип другого размера, поведение указателя меняется
                li Для указателя определены сложение и вычитание с целыми числами
                li Два указателя можно вычесть друг из друга. Если первый указатель меньше второго, или указатели от разных массивов - UB
        section.slide
            h2 Операции над указателями
            ul
                li Указатель на обрасть памяти, следующую за последним элеменом массива - частая практика, однако разыменовывать его нельзя
                li Операция обращения по индексу так же применима к указателям. При этом допустимы отрицательные индексы в случае, когда не происходит выхода за пределы массива
        section.slide
            h2 Указатели и #[code const]
            ul
                li #[code const] до символа #[code *] - нельзя изменять данные, на которые ссылается указатель
                li #[code const] после символа #[code *] - нельзя менять сам указатель
                li Т.о. в типе может использоваться два раза ключевое слово #[code const]: #[code const char* const s = ...]
        section.slide
            h2 Представление строки
            ul
                li Фактически, строка - это массив символов #[code char], где последний символ равен #[code '\0']
                li Все функции для работы над строками считают нулевой байт концом строки. При применении таких функций к бинарным данным результат может быть рекорректным
                li Все функции ожидают указатель на первый символ строки, и получают следующие символы инкрементом. Если строка не заканчивается нулевым байтом, будет выход за пределы массива
        section.slide
            h2 Представление строки
            ul
                li Размер массива для хранения строки всегда минимум на единицу больше самой строки
                li #[code const] при объявлении строки может влиять на размещение в памяти: #[code const char[] str = "Hello";] может быть размещена в области памяти, доступной только для чтения. Язык #[code C] позполяет снять константность, но в этом случае может быть segmentation fault
        section.slide
            h2 Функции для обработки строк
            ul
                li Функция может обработать строку "на месте" - результат будет записан в том же буффере. Применимо в случае, когда размер результирующей строки не больше исходной
                li Функция может вернуть строку в новом динамически выделенном буфере (с помощью #[code malloc] и #[code realloc]) - в этом случае необходимо освобождать память (#[code free])
                li Функция может принимать буфер для результата (и его размер)
        section.slide
            h2 Функции для обработки строк
            pre
                code(style="font-size: 14pt;").
                    char *concatenate(const char *str1, const char *str2)
                    {
                        size_t len1 = strlen(str1);
                        size_t len2 = strlen(str2);
                        char *ret = malloc(len1 + len2 + 1); // не забываем \0-байт
                        if (ret) {
                            memcpy(ret, str1, len1);
                            memcpy(ret + len1, str2, len2 + 1);
                        }
                        return ret;
                    }
        section.slide
            h2 Функции для обработки строк
            p.
                Если функция принимает только один параметр для записи строки-результата - адрес буфера,
                при этом невозможно контролировать длину строки, которая будет записана в этот буфер, такую
                функцию использовать крайне опасно (по меньшей мере). Например, функция #[code gets], которая
                считывает одну строку из стандартного потока ввода и сохраняет ее по указанному адресу,
                безусловно запрещена к использованию
        section.slide
            h2 Чтение строки
            ul
                li #[code char *fgets(char *buf, size_t size, FILE *fin);]
                li Возвращает NULL при ошибке чтения или достижении конца файла. В противном случае функция возвращает указатель #[code buf]
                li Строка текста заканчивается либо символом '\n', либо концом файла, либо исчерпанием места в буфере #[code buf]
                li Если символ #[code '\n'] считан, он помещается в буфер
                li Функцию допустимо использовать, когда есть ограничение на максимальную длину строки текста во входном файле
        section.slide
            h2 Чтение строки
            ul
                li У функций семейства scanf есть форматное преобразование %s. Оно требует указатель на буфер строки
                li Предварительно пропускаются все пробельные символы, чтение в строку ведется либо до конца файла, либо до первого пробельного символа
                li Необходимо указать максимальное число считываемых символов следующим образом (просто #[code %s] недопустим)
        section.slide
            h2 Вывод строки
            ul
                li #[code printf("%s", buf);]
                li #[code fputs(buf, stdout);]
                li #[code printf(buf);] - #[b запрещено]! #[a(href="https://www.youtube.com/watch?v=0WvrSfcdq1I") Пример эксплоита]
        section.slide
            h2 Форматное чтение и запись
            ul
                li #[code int snprintf(char *buf, size_t size, const char *format, ...);]
                li #[code int sscanf(char *str, const char *format, ...);]
                li В случае чтения из строки удобно использовать форматное преобразование #[code %n]
        section.slide
            h2 Контролируемое преобразование из строки в число
            ul
                li Требуется, чтобы при чтении числа не возникало переполнение, в хвосте числа не находится "мусор"
                li Допустимо - "12", " -12" (пробелы перед числом допускаются)
                li #[code strtol], #[code strtoll], #[code strtoul], #[code strtoull], #[code strtod]
        section.slide
            h2 Контролируемое преобразование из строки в число
            ul
                li Если возникло переполнение, в переменную #[code errno] записывается код ошибки #[code ERANGE]
                li В переменную, адрес которой передан вторым параметром, записывается указатель на первый символ, который не является частю считанного числа
        section.slide
            h2 Контролируемое преобразование из строки в число
            p Проверка корректности чтения с помощью strtol заключается в следующем:
            ul
                li проверить, что строка не пуста
                li проверить, что переменная errno не установлена
                li проверить, что eptr указывает на нулевой байт
        section.slide
            h2 Инициализация выделенной памяти
            ul
                li #[code void *memset(void *s, int c, size_t n);] - заполняет массив из #[code n] байт, который находится по адресу #[code s] однобайтными значениями #[code c]
                li Эту функцию можно (и нужно) вызывать после выделения памяти для массива или буфера, иначе с большой вероятностью, выделенная память будет содержать какие-то случайные значения
        section.slide
            h2 Динамическое выделение памяти
            ul
                li #[code void* malloc(size_t n_bytes);]
                li #[code void free(void *pointer);]
                li #[code void *realloc(void *oldptr, size_t newsize);]

    
        div(class="progress")
        script(src="../../../common/shower/shower.min.js")