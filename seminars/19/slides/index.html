<!DOCTYPE html><html lang="en"><head><title>Архитектура компьютера и операционные системы</title><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../../common/shower/themes/ribbon/styles/screen-16x10.css"><style type="text/css">.caption {
    color: #FFF;
}</style></head><body class="shower list"><header class="caption"><h1>Архитектура компьютера и операционные системы</h1><p>Семинар 19. Сигналы</p></header><section id="cover" class="slide"><h2>Семинар 19. Сигналы</h2><p>Архитектура компьютера и операционные системы @ ВШЭ, 2019-2020</p><img src="../../../common/cover.jpg" alt="" class="cover"><style type="text/css">#cover h2 {
    margin: 30px 0 0;
    color: #FFF;
    text-align: center;
    font-size: 70px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p {
    margin: 10px 0 0;
    text-align: center;
    color: #FFF;
    font-style: italic;
    font-size: 20px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p a {
    color: #FFF;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
</style></section><section class="slide"><h2>Сигналы</h2><ul><li>Сигнал - программное прерывание нормальной работы процесса</li><li>Некоторые сигналы сообщают об ошибках, таких как недопустимое обращение к памяти, другие сообщают об асинхронных событиях, таких как потеря связи с терминалом</li><li>Некоторые события делают нежелательным или невозможным продолжение нормальной работы процесса, такие сигналы по умолчанию завершают работу процесса. Другие сигналы, сообщающие о «безобидных» событиях, по умолчанию игнорируются</li></ul></section><section class="slide"><h2>Сигналы</h2><ul><li>Процесс может послать сигнал другому процессу. Это позволяет, например, родительскому процессу завершить выполнение дочернего процесса</li><li>Обработка сигналов в системах-наследницах <code>System V</code> сильно отличается от таковой в семействе <code>BSD</code>. Однако, в <code>LINUX</code> за основу принята обработка в стиле <code>BSD</code></li></ul></section><section class="slide"><h2>Типы сигналов</h2><ul><li><b>Ошибка</b> означает, что программа сделала что-то недопустимое и не может продолжить своё выполнение (например, деление на 0)</li><li><b>Внешнее событие</b> обычно относится к операциям ввода/вывода или другим процессам (например, получение данных при асинхронных операциях)</li><li><b>Явный запрос</b> предполагает использование функций, таких как kill, задача которых — сгенерировать сигнал</li></ul></section><section class="slide"><h2>Типы сигналов</h2><ul><li><b>Синхронные</b> - относится к некоторому действию в программе и генерируется и доставляется (если не заблокирован) во время этого действия (например, большинство ошибок, сигнал, посланный самому себе)</li><li><b>Асинхронные</b> - могут приходить в непредсказуемые моменты времени</li></ul></section><section class="slide"><h2>Генерация сигнала</h2><ul><li>Системный вызов <code>kill</code></li><li><a href="https://www.opennet.ru/man.shtml?topic=kill&amp;category=2">man</a></li><li>Если установить номер сигнала равным <code>0</code>, то сигнал не посылается, но все ошибки проверяются. Это можно использовать, например, для проверки существования процесса с заданным <code>pid</code></li><li><code>int raise(int sig);</code> эквивалентно <code>kill(getpid(), sig);</code></li></ul></section><section class="slide"><h2>Получение сигнала</h2><ul><li>После генерации сигнала он становится <i>ожидающим доставки</i>, обычно - не продолжительное время</li><li>Сигнал может быть заблокированным, тогда он будет ожидать разблокировки, после чего будет доставлен немедленно</li><li>Получение сигнала означание выполенние определенного действия. Для некоторых (<code>SIGKILL</code> и <code>SIGSTOP</code>) действие фиксировано, но для большинства есть выбор: игнорировать, обрабатывать или действовать по умолчанию</li></ul></section><section class="slide"><h2>Получение сигнала</h2><ul><li>Программа может задать обработчик сигнала с помощью <code>signal</code> или <code>sigaction</code></li><li>Если для некоторого типа сигнала установлено игнорирование, любой сигнал такого типа будет сброшен сразу же после генерации, даже если этот тип сигналов в тот момент был заблокирован. Такой сигнал никогда не будет доставлен, даже если программа затем установит обработчик сигнала и разблокирует его</li></ul></section><section class="slide"><h2>Получение сигнала</h2><ul><li>Если не установлен обработчик, и сигнал не игнорируется, то выполняется действие по умолчанию</li><li>Для большинства сигналов - завершить исполнение программы, для некоторых безобидных - не делать ничего</li><li>Сигналы, по умолчанию завершающие процесс, вызывают функцию ядра, аналогичную <code>_exit</code>, то есть не вызываются обработчики завершения, зарегистрированные по <code>atexit</code>, не записываются буферы дескрипторов потока <code>FILE</code></li></ul></section><section class="slide"><h2>Стандартные сигналы</h2><ul> <li>Имена сигналов определены в заголовочном файле <code>signal.h</code></li><li>Макрос <code>NSIG</code> даёт общее количество сигналов, определённых в системе. Поскольку сигналы нумеруются последовательно, его значение на 1 больше максимального номера сигнала</li><li>Для получение строки, описывающей сигнал, можно использовать <code>strsignal</code></li></ul></section><section class="slide"><h2>Стандартные сигналы</h2><ul><li>Описание стандартных сигналов может быть найдено <a href="https://github.com/hseos/hseos-course/blob/master/2017/19-signal1/sem-signals.pdf">здесь</a></li><li>Когда процесс остановлен, он не может получать сигналы, кроме <code>SIGKILL</code> и <code>SIGCONT</code>. Все посланные процессу сигналы будут сделаны ожидающими доставки</li><li>Когда процесс получает сигнал <code>SIGCONT</code>, все сигналы остановки, ожидающие доставки, будут сброшены. Аналогично, когда процесс получает сигнал остановки, все сигналы <code>SIGCONT</code>, ожидающие доставки, будут сброшены</li></ul></section><section class="slide"><h2>Работа с множествами сигналов</h2><ul><li>Аргументами многих функций, работающих с сигналами, могут быть множества сигналов</li><li>Тип <code>sigset_t</code> должен использоваться для хранения множества сигналов</li><li>Функции для работы с множествами сигналов: <code>sigemptyset</code>, <code>sigfillset</code>, <code>sigaddset</code>, <code>sigdelset</code>, <code>sigismember</code></li></ul></section><section class="slide"><h2>Установка обработчика сигнала</h2><ul><li><a href="https://www.opennet.ru/man.shtml?topic=signal&amp;category=2">signal</a></li><li>Если процесс игнорирует сигнал <code>SIGSEGV</code> и другие аналогичные сигналы, его поведение после ошибки неопределено</li><li>Игнорировать запросы пользователя, такие как <code>SIGINT</code> и пр. — недружественно по отношению к пользователю</li><li>Функция <code>signal</code> присутствует в стандарте <code>ANSI C</code>, тем не менее её использование не рекомендуется по историческим причинам</li></ul></section><sections class="slide"><h2>Установка обработчика сигнала</h2><ul><li><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=sigaction&amp;category=2">sigaction</a></li><li>Позволяет в том числе определить, какое поведение (как в <code>System V</code> или как в <code>BSD</code>) использовать</li></ul></sections><sections class="slide"><h2>Блокирование сигналов</h2><ul><li>Временная блокировка сигнала с помощью <code>sigprocmask</code> позволяет предотвратить прерывание нормальной работы процесса в критической секции кода</li><li>Если работа с этой структурой не атомарна, обработчик сигнала может быть запущен, когда структура находится в нецелостном состоянии, что может приводить к самым неприятным последствиям</li><li>Сигнал будет доставлен после его разблокировки</li></ul></sections><section class="slide"><h2>Ожидание прихода сигналов</h2><ul><li><code>pause</code> приостанавливает выполнение процесса до поступления сигнала, который не блокируется и не игнорируется</li><li>Если поступление сигнала запускает функцию обработки сигнала, которая возвращает управление в процесс, функция pause возвращается с кодом завершения <code>-1</code> и кодом ошибки <code>EINTR</code> даже в случае, когда включена семантика перезапускаемых системных вызовов</li><li>Однако, с <code>pause</code> можно получить ошибки обработки сигналов, связанные с асинхронностью их природы</li></ul></section><section class="slide"><h2>Ожидание прихода сигналов</h2><ul><li>Более правильный способ - использование <code>sigprocmask</code> совместно с <code>sigsuspend</code></li><li><sigsuspend></sigsuspend> временно устанавливает маску блокировки сигналов на переданную ему, а затем ждет сигнал, который либо вызывает завершение процесса, либо обрабатывается процессом</li></ul></section><div class="progress"></div><script src="../../../common/shower/shower.min.js"></script></body></html>